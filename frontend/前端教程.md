# 前端样式调整速查

本文记录了近期在 `ModelChat.vue` 中调试气泡消息样式时用到的 CSS 技巧，以及后续可能需要扩展的操作步骤，方便在其他页面复用。

## 1. 气泡消息布局要点

- **结构定位**：消息文本容器位于 `.message-text`，外层 `.message-content-wrapper` 负责宽度与对齐（用户消息右对齐，助手消息左对齐）。
- **最小尺寸**：通过 `min-width: 120px` 和 `min-height: 20px` 确保气泡在内容为空或流式输出尚未返回时不会塌缩。空内容与流式占位额外设置 `min-height: 48px` 以提供更稳定的占位高度。
- **内边距**：`padding: 8px 16px` 在上下提供 8px 留白，配合 `line-height: 1.5` 获得更自然的段间距。如果需要更紧凑，可根据实际情况调小 `padding`。

```1215:1261:frontend/src/views/ModelChat.vue
.message-text {
  padding: 8px 16px;
  border-radius: 16px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  color: var(--text-color);
  line-height: 1.5;
  word-wrap: break-word;
  white-space: normal;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  min-height: 20px;
  min-width: 120px;
}
```

## 2. 常用伪类与关系选择器

- **伪类（Pseudo-class）**：用于表示元素在特定状态下的样式，例如 `:hover`（鼠标悬停）、`:focus`（获得焦点）、`:empty`（内容为空）等。伪类写在选择器后方，以单冒号 `:` 开头。
- **`:empty` 伪类**：选中**自身没有任何子节点**的元素（包括没有文本、没有子标签）。用于给完全空的气泡设置占位样式。
- **`:has()` 关系伪类**：CSS 选择器 Level 4 新增，用于根据子元素/后代是否满足条件来匹配父级。语法为 `selector:has(child-selector)`，只要括号中的选择器在该元素内部命中，就为父级应用样式。本项目中用来捕捉“气泡内出现空元素”的场景：

```1230:1237:frontend/src/views/ModelChat.vue
.message-text:empty,
.message-text:has(*:empty) {
  min-height: 48px;
  min-width: 120px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

- **伪元素（Pseudo-element）**：用于选择元素内部“虚拟的”子节点，例如文本第一行、首字母或插入额外装饰。语法以双冒号 `::` 开头，例如 `::before`、`::after`、`::first-line`。
- **示例：加载动画点**

```1238:1246:frontend/src/views/ModelChat.vue
.message-item.assistant .message-text:empty::after {
  content: "";
  width: 8px;
  height: 8px;
  background: var(--primary-blue);
  border-radius: 50%;
  animation: pulse 1.5s ease-in-out infinite;
  position: absolute;
}
```

这里的 `::after` 是伪元素，用于在气泡内生成一个小圆点并添加呼吸动画，让“生成中”的状态更直观。

- **段落间距处理**：目前消息气泡中的 Markdown 段落统一设置 `margin: 0.5em;`（见 `.message-text :deep(p)`）。`:deep()` 是 Vue SFC scoped 样式里的“深度选择器”，可让我们选中插槽/子组件渲染出的真实 DOM（例如 Markdown 生成的 `<p>`）。如果不使用 `scoped`，单文件组件 `<style>` 块会在构建时被直接打包成全局样式（没有额外前缀），浏览器加载后会影响任意同名元素，这就是“污染”的根源。加上 `scoped` 后，编译器会给当前组件的 DOM 节点和 CSS 选择器补充一个唯一的哈希属性（例如 `data-v-xxxx`），从而让样式仅在组件内部生效。若后续需要支持多段输出，可以改回 `margin: 0` 并按需要添加相邻兄弟选择器（如 `p + p`）控制段落间距；`p + p` 表示“紧跟前一个 `<p>` 的段落”，也叫兄弟相邻选择器。

## 附录：对象展开运算符 `...`

- **基本概念**：`...obj` 是 ES2018 引入的 Object Spread 语法，用于将对象的可枚举属性浅拷贝到新对象。常见用法是复制原有字段的同时覆盖/新增某些值。
- **示例：重置消息状态**

```399:407:frontend/src/views/ModelChat.vue
sessionDetail.messages = sessionDetail.messages.map(message => {
  return {
    ...message,
    isStreaming: false
  }
});
```

这段代码在加载历史会话时将每条消息拷贝一份，并把 `isStreaming` 统一设为 `false`，避免直接修改原始响应式数据，也防止旧的“流式”状态残留。对象展开同样适用于函数入参、状态更新等场景，是 React/Vue 等前端框架里非常常见的写法。

## 模型对话（流式处理）流程梳理

以下内容总结自 `frontend/src/views/ModelChat.vue`，描述一次完整的模型对话（含流式输出）在前端的处理步骤，并解释关键变量、请求和状态。

1. **发送前准备**
   - 组件通过 `selectedModel`、`selectedPrompt` 记录当前选择的模型及提示词；输入框内容存放在 `inputMessage`。
   - `sendMessage` 中先做基本校验：输入非空、没有正在流式中的消息、模型已选择。
   - 构造 `userMessage` 对象：
     ```js
     const userMessage = {
       id: `user-${Date.now()}`,
       role: 'user',
       content: userMessageContent,
       created_at: new Date().toISOString(),
       requestId: crypto.randomUUID ? crypto.randomUUID() : `req-${Date.now()}`
     }
     ```
     其中 `requestId` 为本地唯一标识，方便后续关联到这次模型请求。

2. **本地预览与落库**
   - 将 `userMessage` 推入 `currentSession.value.messages`，立即在界面展示；
   - 若当前会话没有 ID，先调用 `chatAPI.createSession` 创建会话并刷新侧边栏；
   - 调用 `chatAPI.sendMessage`，附带 `session_id`、`role: 'user'`、`content` 等，将用户消息写入后端数据库，并把接口返回的真实 ID 回写到 `userMessage.id`。

3. **组装模型请求体**
   - 按顺序构造 `messages` 数组：若选择了提示词先推入 `system` 消息，再推入本次用户内容；
   - 组装 `requestData = { model_config_id, messages }`，用于普通对话或流式对话调用。

- **补充：`crypto.randomUUID ? ... : ...`**
  
  在 `sendMessage` 里生成 `requestId` 时用到了 **三元运算符** 与 **模板字符串**：
  
  ```671:680:frontend/src/views/ModelChat.vue
  const userMessage = {
    ...,
    requestId: crypto.randomUUID ? crypto.randomUUID() : `req-${Date.now()}`
  }
  ```
  
  - `条件 ? A : B` 是 JavaScript 的三元（条件）运算符，条件为真执行 A，为假执行 B。
  - 这里条件是浏览器是否支持 `crypto.randomUUID`，若支持就直接生成正式 UUID；否则退化为字符串 `req-时间戳`（模板字符串通过 `` `req-${Date.now()}` `` 插入当前毫秒时间）。
  - 这样能保证无论环境是否支持 Web Crypto，都能得到一个唯一的标识符。

4. **模型响应（普通 / 流式）**
   - 若关闭流式：直接 `POST /api/chat/`，解析返回文本；
   - 若开启流式：调用 `handleStreamingResponse`，SSE 会不断触发 `onChunk` 更新 UI，最后在 `onComplete` 回调里拿到完整的 `finalContent`。

5. **在后台保存模型回复**
   - 无论是否在当前会话，`originalResponseContent` 都会记录模型最终输出；
   - 在代码收尾阶段：
     ```js
     if (originalResponseContent) {
       await chatAPI.sendMessage({
         session_id: originalSessionId,
         content: originalResponseContent,
         role: 'assistant',
         model_name: selectedModel.value || 'unknown'
       })
     }
     ```
     以 `assistant` 角色写入数据库。即使用户中途跳走，该请求仍会在后台完成，历史记录保持完整。

6. **会话切换与状态恢复**
   - 重新打开某个会话时，`selectSession` 会通过 `/api/chat/sessions/{id}` 获取完整消息列表；
   - 为避免恢复时仍显示“正在流式”，我们将每条消息统一展开并设置 `isStreaming: false`：
     ```js
     sessionDetail.messages = sessionDetail.messages.map(message => ({
       ...message,
       isStreaming: false
     }))
     ```
   - 若需要继续显示后台生成状态，可以额外存储状态字段或在 SSE 回调里发送事件通知。

7. **角色标识与展示**
   - 前端根据 `message.role` 决定采用左/右气泡、不同背景色；
   - 数据库保存的 `role` 也区分 `user`、`assistant`（若需要还可扩展 `system`）。

> 小结：这一套流程保证了用户可以自由切换会话，后台仍异步完成答复并落库。回到会话时，既能看到自己的提问，也能看到模型完整输出，不会出现内容错位或丢失。

> ⚠️ 浏览器支持：`:has()` 在 Chrome 105+/Edge/Safari 15.4+ 可用，Firefox 目前处于实验阶段。如果需要兼容旧浏览器，可改为在模板里渲染占位符元素，或通过 JavaScript 条件添加 CSS 类。

## 3. 占位动画与流式提示

- 空气泡默认显示一个呼吸动画（使用 `@keyframes pulse`）。目标元素是 `.message-item.assistant .message-text:empty::after`，动画为 1.5 秒循环，适合提醒“正在生成中”。
- 流式输出时 Vue 会给消息对象标记 `isStreaming`，并在 HTML 上附加 `.streaming-empty` 类。相应样式中同样设置 `min-width`、`min-height` 并使用 `display: flex` 水平垂直居中。

## 4. 自定义建议

1. **修改气泡颜色**：在 `.message-item.user .message-text` 与 `.message-item.assistant .message-text` 中调整背景/边框即可。
2. **调节最大宽度**：默认 `max-width` 设置在 `.message-content-wrapper` 中（70%）。若希望支持更宽文本，可调整该值或针对特定屏幕设置媒体查询。
3. **支持多主题**：颜色全部引用 CSS 变量（如 `var(--bg-color)`），可在主题切换时在根节点更新变量值，避免重复改样式文件。

## 5. 调试技巧

- Chrome DevTools 快捷键 `Ctrl+Shift+C`/`Cmd+Shift+C` 进入元素检查模式，实时查看 padding、margin、content box 等信息，帮助定位高度异常。
- 修改 CSS 后若仍看到旧样式，确保重新构建或刷新浏览器缓存（开发模式下使用 Vite 的 HMR 一般即可立即生效）。
- 遇到高度是奇数或小数的情况，优先检查 padding 与 line-height 的组合；如果 `white-space: pre-wrap` 参与计算，也会因为换行保留而出现额外高度。

---

如需补充更多常用样式片段，可继续往本文件添加章节，建议按“组件/场景”划分，方便检索。

## 附录：UA 默认样式与长度单位 `em`

- **段落 (`<p>`) 默认 margin**：浏览器的 User Agent 样式（自带的基础样式表）会给段落设置 `margin-top: 1em; margin-bottom: 1em;`。这些值等于当前字体大小（例如字体 16px，则外边距 16px）。如果不覆盖，消息气泡内的 Markdown `<p>` 就会天然带着上下 16px 空白。
- **覆盖方式**：在 `ModelChat.vue` 中使用 `:deep(p)` 把 margin 归零，再按需求为相邻段落设置 `margin-top: 8px`，这样高度就完全由我们控制。
- **`em` 单位**：相对于元素自身的字体大小。`1em` 表示 1 × 当前字体尺寸；`0.5em` 就是字体的一半。因为默认 paragraph margin 用的是 `1em`，所以会随字体调整而联动，导致整体高度看起来不稳定。改写为固定像素或特定设计值能让布局更可控。

## Map 数据结构与流式响应状态管理

### Map 基础概念

`Map` 是 JavaScript ES6 引入的**内置键值对集合**，类似于字典或哈希表：

- **键值对存储**：每个键（key）唯一对应一个值（value），通过键快速查找值
- **任意类型键**：与普通对象 `{}` 不同，Map 的键可以是**任意类型**（数字、对象、函数等）
- **保持插入顺序**：Map 会保持键值对的插入顺序，遍历时按插入顺序返回

### Map 常用方法

```js
const map = new Map()

// 1. 设置键值对
map.set('session-123', { id: 'msg-1', content: 'Hello' })

// 2. 获取值
const value = map.get('session-123')  // { id: 'msg-1', content: 'Hello' }

// 3. 检查键是否存在
if (map.has('session-123')) {
  console.log('会话123存在流式响应')
}

// 4. 删除键值对
map.delete('session-123')

// 5. 获取大小
console.log(map.size)  // 当前键值对数量

// 6. 清空所有
map.clear()
```

### 在项目中的应用：跟踪流式响应

在 `ModelChat.vue` 中，我们使用 `Map` 来跟踪每个会话正在进行的流式响应：

```js
// 在 setup() 中声明
const activeStreamingMessages = new Map() // sessionId -> { messageId, message }

// 开始流式响应时记录
activeStreamingMessages.set(sessionId, {
  messageId: assistantMessageId,
  message: assistantMessage
});

// 流式更新时修改内容
const streamingInfo = activeStreamingMessages.get(sessionId);
if (streamingInfo) {
  streamingInfo.message.content = parsed.content;
  streamingInfo.message.thinking = parsed.thinking;
}

// 流式完成或出错时清除
activeStreamingMessages.delete(sessionId);

// 切换回会话时检查并恢复
const streamingInfo = activeStreamingMessages.get(session.id);
if (streamingInfo) {
  // 恢复正在进行的流式消息
  sessionDetail.messages.push(streamingInfo.message);
}
```

### 为什么用 Map 而不是普通对象？

| 特性 | `Map` | 普通对象 `{}` |
|------|-------|--------------|
| 键类型 | 任意类型（数字、对象等） | 只能是字符串/Symbol |
| 键查找 | `map.has(key)` 语义清晰 | 需要 `key in obj` 或 `obj.hasOwnProperty` |
| 获取大小 | `map.size` 直接获取 | 需要 `Object.keys(obj).length` |
| 删除键 | `map.delete(key)` | `delete obj[key]` |
| 性能 | 频繁增删性能更好 | 静态结构更快 |
| 遍历 | `map.forEach()` 或 `for...of` | `for...in` 或 `Object.keys()` |

---

## 完整的对话流程与会话切换逻辑

### 设计目标

1. **用户可以在模型回复期间切换到其他会话**，不会被阻塞
2. **流式响应在后台继续进行**，即使用户离开了当前会话
3. **切换回原会话时自动恢复显示**正在进行的流式输出
4. **流式完成后保存到数据库**，无论用户是否还在该会话
5. **避免重复创建会话**，确保一条消息只创建一个会话

### 核心问题与解决方案

#### 问题1：通过索引更新消息导致错位

**问题描述**：
```js
// ❌ 错误做法：通过数组末尾索引更新
const messageIndex = currentSession.value.messages.length - 1;
currentSession.value.messages[messageIndex].content = newContent;
```

当用户切换会话后，`currentSession.value.messages` 变成了其他会话的消息列表，索引就指向了错误的消息。

**解决方案**：通过唯一ID查找消息

```js
// ✅ 正确做法：生成唯一ID并通过ID查找
const assistantMessageId = `assistant-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

const findMessageById = (messages, id) => {
  return messages.findIndex(msg => msg.id === id);
};

// 更新时通过ID查找
const messageIndex = findMessageById(currentSession.value.messages, assistantMessageId);
if (messageIndex !== -1) {
  currentSession.value.messages[messageIndex].content = newContent;
}
```

#### 问题2：切换会话后无法继续接收流式内容

**问题描述**：
流式响应的 `onChunk` 回调只在 `currentSession.value.id === sessionId` 时更新UI，切换后就看不到内容了。

**解决方案**：使用 Map 在后台持续更新

```js
// onChunk 回调中：先更新 Map，再根据会话ID决定是否更新UI
(currentContent) => {
  const parsed = parseThinkingContent(currentContent);
  
  // 1. 更新 activeStreamingMessages（后台持续更新）
  const streamingInfo = activeStreamingMessages.get(sessionId);
  if (streamingInfo) {
    streamingInfo.message.content = parsed.content;
    streamingInfo.message.thinking = parsed.thinking;
  }
  
  // 2. 只在当前会话时更新UI
  if (currentSession.value.id === sessionId) {
    const messageIndex = findMessageById(currentSession.value.messages, assistantMessageId);
    if (messageIndex !== -1) {
      currentSession.value.messages[messageIndex] = {
        ...currentSession.value.messages[messageIndex],
        content: parsed.content,
        thinking: parsed.thinking,
        isStreaming: true
      };
      scrollToBottom();
    }
  }
}
```

#### 问题3：切换回会话时流式消息丢失

**解决方案**：在 `selectSession` 中检查并恢复

```js
const selectSession = async (session) => {
  // 1. 从数据库加载历史消息
  const response = await chatAPI.getSession(session.id);
  const sessionDetail = response.data;
  
  // 2. 重置所有历史消息的流式状态
  sessionDetail.messages = sessionDetail.messages.map(message => ({
    ...message,
    isStreaming: false
  }));
  
  // 3. 检查是否有正在进行的流式响应
  const streamingInfo = activeStreamingMessages.get(session.id);
  if (streamingInfo) {
    // 检查消息是否已在列表中
    const existingIndex = sessionDetail.messages.findIndex(
      msg => msg.id === streamingInfo.messageId
    );
    if (existingIndex === -1) {
      // 如果不在，添加正在流式的消息
      sessionDetail.messages.push(streamingInfo.message);
      console.log('🔄 恢复正在进行的流式响应');
    }
  }
  
  currentSession.value = sessionDetail;
  await nextTick();
  scrollToBottom();
};
```

#### 问题4：模型输出完成后多出空会话

**问题描述**：
代码中有两个地方创建会话，导致重复创建：
1. 发送用户消息前创建会话（正确）
2. 保存AI回复时再次检查并创建会话（错误）

**解决方案**：删除第二个创建逻辑

```js
// ✅ 只在发送用户消息前创建会话一次
try {
  if (!originalSessionId) {
    const title = userMessageContent.length > 20
      ? userMessageContent.substring(0, 20) + '...'
      : userMessageContent;
    const sessionResponse = await chatAPI.createSession({ title });
    originalSessionId = sessionResponse.data.id;
    currentSession.value.id = originalSessionId;
    await loadSessions(); // 刷新侧边栏列表
  }

  // 保存用户消息
  await chatAPI.sendMessage({
    session_id: originalSessionId,
    content: userMessageContent,
    role: 'user',
    model_name: selectedModel.value
  });
} catch (error) {
  console.error('保存用户消息失败:', error);
  return;
}

// ... 流式响应处理 ...

// ✅ AI回复保存：不再检查 currentSession.value.id
try {
  if (originalResponseContent) {
    await chatAPI.sendMessage({
      session_id: originalSessionId,  // 使用保存的原始会话ID
      content: originalResponseContent,
      role: 'assistant',
      model_name: selectedModel.value
    });
    await loadSessions(); // 刷新列表以更新时间戳
  }
} catch (error) {
  console.error('保存AI回复失败:', error);
}
```

### 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 用户发送消息                                                   │
├─────────────────────────────────────────────────────────────────┤
│ - 校验：非空、模型已选、无正在流式的消息                           │
│ - 生成 userMessage (带 requestId)                                │
│ - 立即推入 currentSession.messages 显示                          │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. 创建会话（如果是新会话）                                        │
├─────────────────────────────────────────────────────────────────┤
│ if (!originalSessionId) {                                       │
│   - 调用 chatAPI.createSession({ title })                       │
│   - 保存 originalSessionId = response.data.id                   │
│   - 更新 currentSession.value.id                                │
│   - 刷新侧边栏列表 loadSessions()                                │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. 保存用户消息到数据库                                            │
├─────────────────────────────────────────────────────────────────┤
│ - 调用 chatAPI.sendMessage({ session_id, role: 'user', ... })  │
│ - 更新 userMessage.id = savedUserMessage.data.id               │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. 发起流式响应                                                   │
├─────────────────────────────────────────────────────────────────┤
│ - 生成唯一 assistantMessageId                                    │
│ - 创建空的 assistantMessage { isStreaming: true }               │
│ - 推入 currentSession.messages                                  │
│ - 记录到 Map: activeStreamingMessages.set(sessionId, {...})    │
│ - 调用 createSSEStream() 开始流式传输                            │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. SSE 流式接收（onChunk 回调）                                   │
├─────────────────────────────────────────────────────────────────┤
│ 每次收到数据块：                                                   │
│ 1. 解析内容 parseThinkingContent(currentContent)                │
│ 2. 更新 Map 中的消息（后台持续更新）                              │
│    streamingInfo.message.content = parsed.content               │
│ 3. 如果当前显示该会话（currentSession.id === sessionId）        │
│    - 通过 ID 查找消息索引                                         │
│    - 更新界面显示                                                 │
│    - 滚动到底部                                                   │
│                                                                 │
│ ⚠️ 关键：即使用户切走，Map 仍在后台更新                           │
└─────────────────────────────────────────────────────────────────┘
                            ↓
                    ┌───────┴────────┐
                    │ 用户切换会话？   │
                    └───────┬────────┘
                           YES │         NO
                    ┌──────────┴──────────┐
                    ↓                     ↓
        ┌────────────────────┐   ┌─────────────────┐
        │ selectSession()    │   │ 继续当前会话     │
        ├────────────────────┤   └─────────────────┘
        │ 1. 加载历史消息     │            ↓
        │ 2. 重置 isStreaming │   ┌─────────────────┐
        │ 3. 检查 Map 恢复    │   │ SSE 流式继续     │
        │    流式消息         │   └─────────────────┘
        └────────────────────┘            ↓
                    │                     │
                    └──────────┬──────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 6. 流式完成（onComplete 回调）                                     │
├─────────────────────────────────────────────────────────────────┤
│ - 清除 Map: activeStreamingMessages.delete(sessionId)          │
│ - 如果当前显示该会话：设置 isStreaming: false                     │
│ - 通过回调传递 finalContent 给上层                               │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ 7. 保存 AI 回复到数据库                                            │
├─────────────────────────────────────────────────────────────────┤
│ if (originalResponseContent) {                                  │
│   - 调用 chatAPI.sendMessage({                                  │
│       session_id: originalSessionId,  // 使用原始会话ID          │
│       role: 'assistant',                                        │
│       content: originalResponseContent                          │
│     })                                                          │
│   - 刷新会话列表 loadSessions() 更新时间戳                        │
│ }                                                               │
│                                                                 │
│ ⚠️ 不再检查 currentSession.value.id，避免重复创建会话             │
└─────────────────────────────────────────────────────────────────┘
                            ↓
                    ┌───────────────┐
                    │ 流程完成       │
                    │ sending = false│
                    └───────────────┘
```

### 关键技术点总结

1. **唯一ID生成**：`assistant-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` 确保消息ID唯一
2. **通过ID查找**：避免使用数组索引，防止会话切换后错位
3. **Map 状态管理**：用 `sessionId` 作为键，跟踪每个会话的流式响应
4. **双路更新**：`onChunk` 中同时更新 Map（后台）和 UI（当前会话）
5. **状态恢复**：`selectSession` 检查 Map 并恢复正在流式的消息
6. **单点创建会话**：只在发送用户消息前创建一次，避免重复
7. **原始会话ID保存**：使用 `originalSessionId` 变量保存，确保保存时不受会话切换影响

---

## 附录：Promise 与 `await` 用法解析

- **`chatAPI.sendMessage` 返回值**：该方法内部使用 Axios 发送 HTTP 请求，因此返回的是一个 Promise。Promise 是"将在未来某个时刻得到结果"的占位对象，状态从 `pending`（进行中）转为 `fulfilled`（成功）或 `rejected`（失败）。
- **`await` 的作用**：`await` 只能出现在 `async` 函数内。当执行到 `await chatAPI.sendMessage(...)` 时，当前函数会被挂起，把执行权交还事件循环，等到 Promise 变为 `fulfilled` 后再继续往下走。这样我们就能像写同步代码一样直接拿到响应结果，而不是手动写 `.then()`。
- **赋值语句本质**：

  ```js
  const savedUserMessage = await chatAPI.sendMessage({ ... })
  ```

  上面一行可以理解为"调用 `chatAPI.sendMessage`，等待 Promise resolve，并把返回的响应对象赋值给 `savedUserMessage`"。后续就可以直接读 `savedUserMessage.data.id` 等字段。如果省略 `await`，变量接收到的是 Promise 本身，必须额外 `.then(res => res.data)` 才能取得真正数据。
- **为什么这不是阻塞**：JavaScript 运行在单线程事件循环模型下，`await` 会暂停当前函数的后续语句，但不会锁死 UI。Promise 挂起期间，浏览器仍可渲染、响应用户交互。等网络请求返回，事件循环会把该异步函数重新放入任务队列执行后续逻辑。这与 Python `asyncio` 里"`await` 出让控制权"是同一个思想，只是术语不同。
- **错误处理**：若 `chatAPI.sendMessage` 被拒绝（Promise rejected），`await` 会抛出异常，可用 `try...catch` 捕获并做提示或重试。

