================================================================================
四、 系统详细设计与实现
================================================================================

（一）用户认证模块
用户认证模块实现用户注册、登录、密码重置及Token刷新功能，系统采用bcrypt算法加密存储密码，JWT双令牌机制保障接口安全。

1.页面展示
用户在注册页面填写邮箱、昵称和密码，系统校验输入合法性后创建账号。登录页面支持邮箱或昵称登录，登录成功后跳转至系统首页。

图4-1-1 用户注册页面

图4-1-2 用户登录页面

2.前端关键程序代码如下
```html
<template>
  <div>
    <AuthNavbar />
  <div class="login-container">
    <div class="login-card">
      <div class="login-header">
        <h1>企业模型训练平台</h1>
        <p>智能化模型训练与管理解决方案</p>
      </div>
      <el-form
        ref="loginForm"
        :model="loginData"
        :rules="loginRules"
        class="login-form"
        @submit.prevent="handleLogin"
      >
        <el-form-item prop="login">
          <el-input
            v-model="loginData.login"
            placeholder="邮箱或昵称"
            size="large"
            :prefix-icon="User"
          />
        </el-form-item>
        <el-form-item prop="password">
          <el-input
            v-model="loginData.password"
            type="password"
            placeholder="密码"
            size="large"
            :prefix-icon="Lock"
            show-password
            @keyup.enter="handleLogin"
          />
        </el-form-item>
        <div class="login-actions">
          <el-button
            :loading="loading"
            type="primary"
            size="large"
            style="width: 100%"
            @click="handleLogin"
          >
            登录
          </el-button>
        </div>
      </el-form>
    </div>
  </div>
  </div>
</template>
```
该前端代码使用Vue 3和Element Plus组件库构建登录页面，包含邮箱或昵称输入框和密码输入框，通过表单校验规则验证输入合法性，点击登录按钮触发handleLogin方法向后端发起认证请求。

```javascript
const handleLogin = async () => {
  if (!loginForm.value) return
  try {
    await loginForm.value.validate()
    loading.value = true
    localStorage.removeItem('token')
    localStorage.removeItem('user')
    localStorage.removeItem('refresh_token')
    const response = await authAPI.login(loginData)
    if (response.data.access_token) {
      localStorage.setItem('token', response.data.access_token)
    }
    await store.dispatch('login', response.data.user)
    message.success(response.data.message || '登录成功')
    setTimeout(() => {
      router.push('/dashboard')
    }, 100)
  } catch (error) {
    message.error(error.response?.data?.detail || '登录失败')
  } finally {
    loading.value = false
  }
}
```
该核心程序代码主要实现了前端登录的功能，包括清除旧的认证信息、调用后端登录接口、将Access Token存储到localStorage、将用户信息保存到Vuex状态管理中，并在登录成功后跳转至系统首页。

3.后端关键程序代码如下
```python
@router.post("/register", response_model=UserResponse)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    # 检查邮箱是否已存在
    if get_user_by_email(db, user_data.email):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="邮箱已被注册"
        )
    # 检查昵称是否已存在
    if get_user_by_nickname(db, user_data.nickname):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="昵称已被使用"
        )
    # 创建用户
    user = create_user(db, user_data.email, user_data.nickname, user_data.password)
    return user
```
该核心程序代码主要实现了用户注册的功能，包括校验邮箱和昵称的唯一性，校验通过后调用create_user函数创建新用户，该函数内部使用bcrypt算法对密码进行哈希处理后存储到数据库。

```python
@router.post("/login", response_model=LoginResponse)
async def login(user_data: UserLogin, response: Response, request: Request, db: Session = Depends(get_db)):
    user = authenticate_user(db, user_data.login, user_data.password)
    if not user:
        existing_user = db.query(User).filter(
            (User.email == user_data.login) | (User.nickname == user_data.login)
        ).first()
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="密码错误"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="邮箱或昵称不存在"
            )
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="账号已被禁用"
        )
    access_token = create_access_token(data={"sub": str(user.id)})
    refresh_token = create_refresh_token(data={"sub": str(user.id)})
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        secure=cookie_secure,
        samesite="lax",
        max_age=7 * 24 * 60 * 60,
        path="/"
    )
    return LoginResponse(
        user=user,
        message="登录成功",
        access_token=access_token
    )
```
该核心程序代码主要实现了用户登录的功能，包括验证用户身份、区分账号不存在与密码错误的情况、检查账号是否被禁用，验证通过后签发Access Token和Refresh Token，其中Refresh Token通过HttpOnly Cookie存储以防止XSS攻击。

（二）模型配置管理模块
模型配置管理模块实现对多个大语言模型提供商的统一配置管理，用户可添加、编辑和删除模型配置。

1.页面展示
模型配置列表采用卡片式布局，每个卡片显示模型提供商图标、模型名称、API端点和状态标签。点击添加按钮弹出配置对话框，用户选择提供商后输入API地址和密钥，系统自动获取可用模型列表。

图4-2-1 模型配置列表页面

图4-2-2 添加模型配置对话框

2.前端关键程序代码如下
```html
<template>
  <div class="model-config-container">
    <el-card class="header-card">
      <div class="header-content">
        <div class="header-left">
          <h2>模型配置管理</h2>
        </div>
        <div class="header-actions">
          <el-button type="info" @click="goToPlayground" :icon="Monitor">
            测试场
          </el-button>
          <el-button type="primary" @click="handleOpenModelDialog" :icon="Plus">
            添加模型
          </el-button>
        </div>
      </div>
    </el-card>
    <div class="model-list" v-loading="loading">
      <div class="model-cards">
        <el-card
          v-for="model in modelConfigList"
          :key="model.id"
          class="model-card"
          shadow="hover"
        >
          <div class="card-content">
            <div class="model-info">
              <ProviderIcon :provider="model.providerId" :size="32" type="color" />
              <div class="model-details">
                <h4 class="model-name">{{ model.modelName }}</h4>
                <el-tag :type="getProviderTagType(model.providerId)" size="small">
                  {{ model.providerName }}
                </el-tag>
              </div>
            </div>
          </div>
        </el-card>
      </div>
    </div>
  </div>
</template>
```
该前端代码构建了模型配置管理页面，使用卡片式布局展示所有已配置的模型，每个卡片包含提供商图标、模型名称和提供商标签，页面顶部提供添加模型和进入测试场的操作按钮。

3.后端关键程序代码如下
```python
@router.post("/", response_model=ModelConfigResponse)
async def create_model_config(
    config: ModelConfigCreate,
    db: Session = Depends(get_db)
):
    existing = db.query(ModelConfigModel).filter(
        ModelConfigModel.provider_id == config.provider_id,
        ModelConfigModel.model_name == config.model_name,
        ModelConfigModel.endpoint == config.endpoint
    ).first()
    if existing:
        raise HTTPException(status_code=400, detail="相同的模型配置已存在")
    db_config = ModelConfigModel(
        id=str(uuid.uuid4()),
        user_id=1,
        provider_id=config.provider_id,
        provider_name=config.provider_name,
        endpoint=config.endpoint,
        api_key=config.api_key,
        model_id=config.model_id,
        model_name=config.model_name,
        type=config.type,
        temperature=config.temperature,
        max_tokens=config.max_tokens,
        status=config.status
    )
    db.add(db_config)
    db.commit()
    db.refresh(db_config)
    return db_config
```
该核心程序代码主要实现了创建模型配置的功能，包括检查是否已存在相同配置、使用UUID生成唯一标识，将配置信息持久化到数据库并返回创建结果。

（三）模型对话模块
模型对话模块实现用户与大语言模型的交互对话，支持会话管理和SSE流式响应。

1.页面展示
界面采用左右分栏布局，左侧为会话列表，右侧为对话区域。用户可创建、切换和删除会话，系统支持SSE流式响应实时展示模型生成的内容，同时解析思维链标签展示推理过程。

图4-3-1 会话管理界面

图4-3-2 流式对话界面

2.后端关键程序代码如下
```python
@router.post("/messages", response_model=ChatMessageResponse)
async def send_message(
    message_data: ChatMessageCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # 如果没有指定会话，创建新会话
    if not message_data.session_id:
        session = ChatSession(user_id=current_user.id, title="新对话")
        db.add(session)
        db.commit()
        db.refresh(session)
        session_id = session.id
    else:
        session_id = message_data.session_id
        # 验证会话属于当前用户
        session = db.query(ChatSession).filter(
            ChatSession.id == session_id,
            ChatSession.user_id == current_user.id
        ).first()
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="聊天会话不存在"
            )
    # 保存消息
    message = ChatMessage(
        session_id=session_id,
        role=message_data.role,
        content=message_data.content,
        model_name=message_data.model_name,
        is_streaming=message_data.is_streaming
    )
    db.add(message)
    db.commit()
    db.refresh(message)
    return message
```
该核心程序代码主要实现了消息发送与持久化的功能，包括自动创建新会话、验证会话归属权限、将消息保存到数据库，支持用户、助手和系统三种角色的消息存储。

（四）模型对比测试模块
模型对比测试模块支持用户选择多个模型进行并行对比测试，系统同时向所有选中模型发送请求，响应结果并排展示，便于直观对比不同模型的响应质量和速度。

1.页面展示

图4-4-1 模型对比测试界面

（五）模型训练管理模块
模型训练管理模块实现训练数据集的上传管理和训练任务的创建、启动、监控等功能。

1.页面展示
用户可上传JSON、JSONL、CSV等格式的训练数据集，创建训练任务时配置基座模型、数据集和训练超参数，任务列表展示所有任务的运行状态和实时进度。

图4-5-1 数据集管理页面

图4-5-2 训练任务管理页面

2.后端关键程序代码如下
```python
@router.post("/datasets", response_model=DatasetResponse)
async def upload_dataset(
    file: UploadFile = File(...),
    name: str = None,
    description: str = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    allowed_formats = ['.json', '.jsonl', '.csv', '.txt']
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in allowed_formats:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"不支持的文件格式，支持的格式: {', '.join(allowed_formats)}"
        )
    upload_dir = "uploads/datasets"
    os.makedirs(upload_dir, exist_ok=True)
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    file_path = os.path.join(upload_dir, unique_filename)
    with open(file_path, "wb") as buffer:
        content = await file.read()
        buffer.write(content)
    file_size = os.path.getsize(file_path)
    dataset = Dataset(
        name=name or file.filename,
        description=description,
        file_path=file_path,
        file_size=file_size,
        format_type=file_extension[1:],
        uploaded_by=current_user.id
    )
    db.add(dataset)
    db.commit()
    db.refresh(dataset)
    return dataset
```
该核心程序代码主要实现了训练数据集上传的功能，包括校验文件格式合法性、使用UUID生成唯一文件名避免重名冲突、将文件保存到服务器并创建数据集记录。

```python
@router.post("/tasks", response_model=TrainingTaskResponse)
async def create_training_task(
    task_data: TrainingTaskCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    dataset = db.query(Dataset).filter(Dataset.id == task_data.dataset_id).first()
    if not dataset:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="数据集不存在"
        )
    output_dir = f"outputs/training/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{task_data.name}"
    os.makedirs(output_dir, exist_ok=True)
    task = TrainingTask(
        name=task_data.name,
        model_name=task_data.model_name,
        dataset_id=task_data.dataset_id,
        config_id=task_data.config_id,
        status="pending",
        progress=0.0,
        output_dir=output_dir,
        created_by=current_user.id
    )
    db.add(task)
    db.commit()
    db.refresh(task)
    return task
```
该核心程序代码主要实现了创建训练任务的功能，包括验证数据集是否存在、按时间戳创建输出目录、初始化任务状态为待运行并持久化到数据库。

（六）训练可视化监控模块
系统集成SwanLab训练可视化工具，用户可在系统内查看Loss曲线、学习率等训练指标图表。

1.页面展示

图4-6-1 SwanLab监控页面

（七）系统提示词管理模块
用户可创建、编辑、删除系统提示词模板，系统支持OpenAI、Ollama等多种格式的提示词验证和相互转换。

1.页面展示

图4-7-1 提示词管理页面

（八）系统管理模块
管理员可查看所有用户列表，启用或禁用用户账号，调整用户角色权限。

1.页面展示

图4-8-1 系统管理页面

2.后端关键程序代码如下
```python
@router.get("/stats")
async def get_admin_stats(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    if not current_user or not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="需要管理员权限"
        )
    total_users = db.query(User).count()
    active_users = db.query(User).filter(User.is_active == True).count()
    admin_users = db.query(User).filter(User.is_admin == True).count()
    return {
        "users": {
            "total": total_users,
            "active": active_users,
            "admins": admin_users
        }
    }
```
该核心程序代码主要实现了系统统计数据获取的功能，包括验证当前用户是否具有管理员权限，查询数据库统计总用户数、活跃用户数和管理员数量并返回结果。

（九）仪表盘与暗色模式
系统首页为仪表盘页面，展示功能导航卡片和关键业务统计数据。同时系统实现了完整的暗色模式切换功能，通过Vuex状态管理和CSS变量实现全局主题切换，用户偏好保存在localStorage中。

1.页面展示
仪表盘页面顶部展示欢迎信息，中间为功能导航卡片区域，包含模型对话、模型测试、模型训练和训练可视化四个快捷入口，底部显示可用模型数、训练任务数、对话会话数和数据集数等统计指标。右上角提供暗色模式切换开关。

图4-9-1 系统仪表盘页面

图4-9-2 暗色模式效果

2.前端关键程序代码如下
```javascript
SET_DARK_MODE(state, isDark) {
  state.isDarkMode = isDark
  localStorage.setItem('darkMode', isDark.toString())
  document.documentElement.classList.add('theme-switching')
  if (isDark) {
    document.documentElement.classList.add('dark-mode')
    document.documentElement.classList.add('dark')
  } else {
    document.documentElement.classList.remove('dark-mode')
    document.documentElement.classList.remove('dark')
  }
  requestAnimationFrame(() => {
    document.documentElement.classList.remove('theme-switching')
  })
}
```
该核心程序代码实现了暗色模式的全局切换功能，通过Vuex mutation管理暗色模式状态，将用户偏好持久化到localStorage，并通过操作document根元素的CSS类名实现主题样式的动态切换，使用requestAnimationFrame确保过渡动画流畅。

（十）Dify应用管理模块
系统集成了Dify应用管理功能，通过iframe嵌入Dify控制台界面，实现对Dify服务的统一管理。页面顶部显示Dify服务的运行状态，并提供打开独立控制台的快捷入口。

1.页面展示

图4-10-1 Dify应用管理页面
